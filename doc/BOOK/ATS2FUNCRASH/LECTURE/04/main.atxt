%{
//
dynload
"libatsdoc/dynloadall.dats"
//
#include
"./../../MYTEXT/ats2funcrash.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
 id="lecture04">
#title("Higher-Order Functions")

#para("\

In ATS, an anonymous function can be defined as a
lambda-abstraction. For instance, the square function on integers can
be defined as follows:

#dats2xhtml('\
//
val
square = lam(x: int): int => x * x
//
')

where the keyword #keycode("lam") is for constructing a
lambda-abstraction.  For defining a recursive anonymous function, the
keyword #keycode("fix") is needed. For instance, the factorial function
can also be implemented as follows:

#dats2xhtml('\
//
val fact =
fix f(x: int): int => if x > 0 then x * f(x) else 1
//
')

A function value can be passed as a function argument just like any
other values, and a higher-order function refers to one that takes a
function value as its argument. As far as terminology is concerned, a
first-order function takes no function arguments; a second-order
function takes a first-order function as its argument; a third-order
function takes a second-order function as its argument; etc. In
practice, higher-order functions are overwhelmingly second-order ones.

")

#para("\

At this point, I want to digress a bit by advocating a so-called
#emphasis("build-your-own-library") approach to learning
programming. Often a limitation faced by someone learning programming
is that one does not have many opportunities to actually use the code
written by oneself. For instance, we rarely see a case where someone
makes extensive use of a data structure (such as hash table and
associative map) implemented by his or her own. Most likely, one
implements some data structure for the purpose of learning about it
and then throws the code away afterwards. My own experience strongly
indicates that one can learn a great deal more about programming if
one insists on calling library functions implemented by oneself. From
this point on, I will gradually build a library for this book and I
encourage everyone reading the book to study the source code for the library
<ulink url=\"https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/ATS2FUNCRASH/LECTURE/MYLIB\">on-line</ulink>.

")

#para("\

As an example of higher-order function, let us implement a commonly
used library function of the name #dyncode("int_foreach"):

#dats2xhtml('\
//
extern
fun
int_foreach
(n0: int, fwork: cfun(int, void)): void
//
')

Note that the type #stacode("cfun(int, void)") is just a shorthand for
#stacode("(int) -&lt;cloref1&gt; void"), which is assigned to a
closure-function that takes an integer argument and returns void.
There are two kinds of functions in ATS: envless function and
closure-function; the former is just a function in the sense of C: a
function pointer to some memory location where a sequence of
instructions is stored; the latter is essentially a function pointer
paired with an environment (represented as a tuple of values) for
certain paramemters. For an envless function from #stacode("int") to
#stacode("void"), its type is written as #stacode("(int) -&gt; void")
or #stacode("(int) -&lt;fun1&gt; void").  While turning an envless
function into a closure-function is straightforward, there is no
generic method for turning a closure-function into an envless
function. Note that each function argument of a higher-order function
is usually chosen to be a closure-function so as to make the
higher-order function more applicable.

")

#para("\

A standard implementation of #dyncode("int_foreach") is given as
follows:

#dats2xhtml('\
//
implement
int_foreach
(n0, fwork) =
loop(0) where {
  fun
  loop(i: int): void =
    if i < n0 then (fwork(i); loop(i+1)) else ()
  // end of [fun loop]
} (* end of [int_foreach] *)
//
')

")

#para("\

For testing #dyncode("fact") (that implements the factorial
function), we can simply make a call to #dyncode("int_foreach")
as follows:

#dats2xhtml('\
//
fun
testfact(n: int): void =
int_foreach(n, lam(i) => println!("fact(", i, ") = ", fact(i)))
//
')

")

#para("\

As another example, let us implement a higher-order function of the
name #dyncode("int_foldleft") as follows:

#dats2xhtml('\
//
extern
fun
{res:t@ype}
int_foldleft
( n0: int
, res: res, fopr: cfun(res, int, res)): res
//
implement
{res}(*tmp*)
int_foldleft
  (n0, res, fopr) =
  loop(res, 0) where
{
//
fun loop(res: res, i: int): res =
  if i < n0 then loop(fopr(res, i), i+1) else res
//
} (* end of [int_foldleft] *)
//
')

Note that #dyncode("int_foldleft") is declared as a function template.
For someone who knows the standard left-folding function on a list
(for folding the list from left to right), #dyncode("int_foldleft")
does essentially the same as left-folding a list consisting of
integers from #dyncode("0") to #dyncode("n-1"), where #dyncode("n") is
the first argument passed to #dyncode("int_foldleft"). For instance,
we can implement the factorial function as follows:

#dats2xhtml('\
//
fun
fact(n: int): int =
int_foldleft<int>(n, 1, lam(res, i) => res * (i+1))
//
')

If we want a function #dyncode("sqsum") to sum up the squares of the
first #dyncode("n") positive integers for any given natural number
#dyncode("n"), we can implement it with a call to #dyncode("int_foldleft") as well:

#dats2xhtml('\
//
fun
sq(i: int): int = i*i
fun
sqsum(n: int): int =
int_foldleft<int>(n, 0, lam(res, i) => res + sq(i+1))
//
')

")

#para("\

Higher-order functions like #dyncode("int_foreach") and
#dyncode("int_foldleft") are often referred to as combinators.  By
making use of combinators, one can often shorten the code needed for
solving a particular problem. Much more importantly, combinators can
help one formulate high-level solutions that tend to significantly
reduce the need for directly handling minute programming details. As
we all know too well, handling such details is a very rich source for
programming errors.

")

#para("\

As the last example in this chapter, let us see
a combinator-based implementation of matrix multiplication.
In imperative programming, the following style of code
is common:

<informalexample><programlisting>
for (i = 0; i < m; i = i+1) for (j = 0; i < n; j = j+1) fwork(i, j);
</programlisting></informalexample>

where one for-loop is embedded in the body of another for-loop.  A
combinator #dyncode("int_cross_foreach") is given as follows for doing
the same:

#dats2xhtml('\
extern
fun
int_cross_foreach
(m: int, n: int, fwork: cfun(int, int, void)): void
//
implement
int_cross_foreach
  (m, n, fwork) =
  int_foreach(m, lam(i) => int_foreach(n, lam(j) => fwork(i, j)))
//
')

The following function #dyncode("matrix_mulby") takes six arguments
#dyncode("p"), #dyncode("q"), #dyncode("r"), #dyncode("A"),
#dyncode("B"), and #dyncode("C"), where it is assumed that
#dyncode("A"), #dyncode("B"), and #dyncode("C") are matrices of
dimensions #dyncode("p") by #dyncode("q"), #dyncode("q") by
#dyncode("r"), and #dyncode("p") by #dyncode("r"), respectively:

#dats2xhtml('\
fun
{a:t@ype}
matrix_mulby
( p:int, q:int, r:int
, A:matrix0(a), B:matrix0(a), C:matrix0(a)
) : void = let
//
val add = gadd_val_val<a>
val mul = gmul_val_val<a>
//
fun
fwork(i: int, j: int): void =
(
  C[i,j] :=
  int_foldleft<a>
  ( q, C[i,j]
  , lam(res, k) => add(res, mul(A[i,k], B[k,j]))
  )
)
//
in
  int_cross_foreach(p, r, lam(i, j) => fwork(i, j))
end // end of [matrix_mulby]
')

Note that the function templates #dyncode("gadd_val_val") and
#dyncode("gmul_val_val") are for addition and multiplication
operations on generic numbers of type #stacode("a"), respectively.
What #dyncode("matrix_mulby") does is simply updating #dyncode("C")
with #dyncode("C") plus the product of #dyncode("A") and
#dyncode("B"). \

")

#para("\

In ATS code, dot-notation is often seen for calling combinators.
For instance, we can introduce the following curried version of
#dyncode("int_foreach") and #dyncode("int_foldleft") plus some
overload declarations:

#dats2xhtml('\
//
extern
fun
int_foreach_method
(n0: int)(fwork: cfun(int, void)): void
//
extern
fun
{res:t@ype}
int_foldleft_method
(n0: int, ty: TYPE(res))
(res: res, fopr: cfun(res, int, res)): res
//
overload .foreach with int_foreach_method
overload .foldleft with int_foldleft_method
//
')

We can then
implement the functions #dyncode("fact") and #dyncode("testfact")
as follows:

#dats2xhtml('\
//
fun fact(n: int): int =
(n).foldleft(TYPE{int})(1, lam(res, i) => res*(i+1))
//
fun testfact(n: int): void =
(n).foreach()(lam(i) => println! ("fact(", i+1, ") = ", fact(i+1)))
//
')

Note that #dyncode("TYPE{int}") is a form of type-annotation; it
indicates to the typechecker of ATS that the template parameter for
the involved instance of #dyncode("int_foldleft_method") is
#stacode("int").

")


#para("\

Please find #mycodelink("LECTURE/04/CODE", "on-line") the entirety of
the code used in this chapter. The multable example mentioned previously
is modified a bit so as to make use of the #dyncode("int_foreach_method")
combinator. \

")#comment("para")

</chapter><!--id="lecture04"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}

